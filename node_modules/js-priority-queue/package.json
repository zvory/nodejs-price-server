{
  "name": "js-priority-queue",
  "version": "0.1.3",
  "description": "Priority queue data structures",
  "main": "priority-queue.js",
  "scripts": {},
  "repository": {
    "type": "git",
    "url": "https://github.com/adamhooper/js-priority-queue"
  },
  "keywords": [
    "priority",
    "queue",
    "bheap",
    "b-heap",
    "binary",
    "heap",
    "dequeue",
    "comparator"
  ],
  "author": {
    "name": "Adam Hooper",
    "email": "adam@adamhooper.com"
  },
  "license": "Public Domain",
  "readmeFilename": "README.md",
  "devDependencies": {
    "browserify": "^11.0.0",
    "chai": "^3.1.0",
    "coffee-script": "^1.10.0",
    "coffeeify": "^1.1.0",
    "del": "^1.2.0",
    "gulp": "^3.9.0",
    "gulp-coffee": "^2.3.1",
    "gulp-mocha": "^2.1.3",
    "gulp-rename": "^1.2.2",
    "gulp-uglify": "^1.2.0",
    "gulp-util": "^3.0.6",
    "karma": "^0.13.2",
    "karma-browserify": "^4.2.1",
    "karma-chai": "~0.1.0",
    "karma-mocha": "^0.2.0",
    "karma-phantomjs-launcher": "^0.2.0",
    "mocha": "^2.2.5",
    "phantomjs": "^1.9.17",
    "vinyl-source-stream": "^1.1.0"
  },
  "readme": "Priority Queue\n==============\n\nA priority queue is a data structure with these operations:\n\n| Operation | Syntax (js-priority-queue) | Description |\n| --------- | --- | ----------- |\n| Create | `var queue = new PriorityQueue();` | Creates a priority queue |\n| Queue | `queue.queue(value);` | Inserts a new value in the queue |\n| Length | `var length = queue.length;` | Returns the number of elements in the queue |\n| Peek | `var firstItem = queue.peek();` | Returns the smallest item in the queue and leaves the queue unchanged |\n| Dequeue | `var firstItem = queue.dequeue();` | Returns the smallest item in the queue and removes it from the queue |\n| Clear | `queue.clear();` | Removes all values from the queue |\n\nYou cannot access the data in any other way: you must dequeue or peek.\n\nWhy use this library? Two reasons:\n\n1. It's easier to use than an Array, and it's clearer.\n2. It can make your code execute more quickly.\n\nInstalling\n==========\n\nYou can `npm install js-priority-queue` or `bower install js-priority-queue`.\nAlternatively, just download `priority-queue.js` from this directory.\n\nInclude it through [RequireJS](http://requirejs.org/) or\n[Browserify](http://browserify.org). Or, to pollute your global scope, insert\nthis in your HTML:\n\n    <script src=\"priority-queue.js\"></script>\n\nThen write code like this:\n\n    var queue = new PriorityQueue({ comparator: function(a, b) { return b - a; }});\n    queue.queue(5);\n    queue.queue(3);\n    queue.queue(2);\n    var lowest = queue.dequeue(); // returns 5\n\nOptions\n=======\n\nHow exactly will these elements be ordered? Let's use the `comparator` option.\nThis is the argument we would pass to\n[Array.prototype.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort):\n\n    var compareNumbers = function(a, b) { return a - b; };\n    var queue = new PriorityQueue({ comparator: compareNumbers });\n\nYou can also pass initial values, in any order. With lots of values, it's\nfaster to load them all at once than one at a time.\n\n    var queue = new PriorityQueue({ initialValues: [ 1, 2, 3 ] })\n\nStrategies\n==========\n\nWe can implement this with a regular `Array`. We'll keep it sorted inversely,\nso `queue.dequeue()` maps to `array.pop()`.\n\nBut with an `Array`, we'll need to `splice()`, which can affect every single\nelement in the array. An alternative is to create a\n[Binary Heap](http://en.wikipedia.org/wiki/Binary_heap), which writes far\nfewer array elements when queueing (though each element is written more slowly).\n\nFinally, we can use a [B-Heap](http://en.wikipedia.org/wiki/B-heap). It's like a\nbinary heap, except it orders elements such that during a single operation,\nwrites occur closer to each other in memory. Unfortunately, it's slower to\ncalculate where in memory each write should occur (it costs a function call\ninstead of a bit-shift). So while it's fast in theory, it's slower in practice.\n\nCreate the queues like this:\n\n    var queue = new PriorityQueue({ strategy: PriorityQueue.ArrayStrategy }); // Array\n    var queue = new PriorityQueue({ strategy: PriorityQueue.BinaryHeapStrategy }); // Default\n    var queue = new PriorityQueue({ strategy: PriorityQueue.BHeapStrategy }); // Slower\n\nYou'll see running times like this:\n\n| Operation | Array | Binary heap | B-Heap |\n| --------- | ----- | ----------- | -------------- |\n| Create | O(n lg n) | O(n) | O(n) |\n| Queue | O(n) (often slow) | O(lg n) (fast) | O(lg n) |\n| Peek | O(1) | O(1) | O(1) |\n| Dequeue | O(1) (fast) | O(lg n) | O(lg n) |\n\nAccording to [JsPerf](http://jsperf.com/js-priority-queue-queue-dequeue), the\nfastest strategy for most cases is `BinaryHeapStrategy`. Only use `ArrayStrategy`\nonly if you're queuing items in a very particular order. Don't use\n`BHeapStrategy`, except as a lesson in how sometimes miracles in one\nprogramming language aren't great in other languages.\n\nContributing\n============\n\n1. Fork this repository\n2. Run `npm install`\n3. Write the behavior you expect in `spec-coffee/`\n4. Edit files in `coffee/` until `gulp test` says you're done\n5. Run `gulp` to update `priority-queue.js` and `priority-queue.min.js`\n6. Submit a pull request\n\nLicense\n=======\n\nI, Adam Hooper, the sole author of this project, waive all my rights to it and\nrelease it under the [Public\nDomain](http://creativecommons.org/publicdomain/zero/1.0/). Do with it what you\nwill.\n",
  "bugs": {
    "url": "https://github.com/adamhooper/js-priority-queue/issues"
  },
  "_id": "js-priority-queue@0.1.3",
  "_from": "js-priority-queue@"
}
